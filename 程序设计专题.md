# 程序设计专题
1.[[模块化程序设计]]:
	递归函数，预处理命令（include、条件编译、define、头文件保护），全局变量extern声明，static全局变量，static函数，多文件的组织 #递归，预处理，全局变量
2.[[指针进阶]]
	二级指针的概念与变量定义；指针数组，指针数组和二级指针的关系，命令行参数；数组指针，二维数组和指针（数组指针、元素级指针）的关系，二维数组名作为函数的参数；多个字符串的处理（二维字符数组、字符指针数组）；函数指针 #指针
3.[[链表]] 
	动态内存分配，链表的定义、创建和基本操作（增、删、插、遍历），链表与数组的对比 #链表
4.[[图形程序设计基础]]
	Windows API的概念，Windows程序基本结构（消息机制），交互式GUI编程基础（第三方图形库基本图形函数、编程模型 #API，GUI
5.[[文件进阶]]
	位运算，二进制文件的操作和应用 ，文件的应用 #文件
6. [[算法分析基础]]
	算法效率的度量方法和大O记法、常见排序（选择、冒泡、归并、插入）与查找算法（二分、线性）介绍与分析、位运算 #排序






## final
迷宫游戏，设计一个迷宫游戏的地图编辑器，并实现游戏的手动和程序求解。
![[Pasted image 20230522095047.png]]
### 基本功能要求
#### 地图生成
地图中至少需包含玩家、障碍物、起点、终点等元素。支持交互式手动编辑地图和自动随机生成地图。
#### 迷宫求解
手动求解，使用键盘方向键走迷宫，到达终点即胜利。
程序自动求解，可视化显示最短路线、所有可行路线等，支持单步执行、自动执行等。
#### 支持菜单和工具栏（快捷键）功能
文件：新建地图、打开地图、保存地图、退出等，
地图编辑：随机生成、手动编辑、元素选择等
地图求解：手动求解、程序求解、展示所有可行解等
帮助：使用说明、关于

### 高级功能要求
手动求解的提示功能：提示下一步可走的格子。

程序求解过程可视化：除了可视化最短路径，可以将求解的过程可视化。

增强游戏性，给玩家添加生命值属性，增加门/钥匙道具，消耗钥匙可以打开门，在此基础上找到最优路径。

libgraphics/ simpleGUI图形库


~~~c
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <windows.h>
#include <time.h>
#include <math.h>

#include "parameter.h"
#include "showMaze.h"
#include "maze.h"



#include "../C_Final/src/libgraphics/graphics.h"
#include "../C_Final/src/libgraphics/genlib.h"
#include "../C_Final/src/simpleGUI/imgui.h"
#include "../C_Final/src/libgraphics/extgraph.h"

void initMaze()
{

	//	将地图初始化成全0的
	for (int i = 0; i < mazeCountX; i++)
	{
		for (int j = 0; j < mazeCountY; j++)
		{
			mazeMap[i][j] = 0;
		}
	}
	//	实现空地与墙壁间隔
	for (int i = 0; i < mazeCountX; i++)
	{
		for (int j = 0; j < mazeCountY; j++)
		{

			if (i != 0 && j != 0 && i != mazeCountX - 1 && j != mazeCountY - 1)
			{
				if (i % 2 != 0)
				{
					if (j % 2 == 1)
					{
						mazeMap[i][j] = 1;
					}
				}
			}
		}
	}
	//	mazeLevel == 0，简单模式生成地图
	if (mazeLevel == 0)
	{
		createEasyMaze(1, 1);
	}
	//	mazeLevel == 1，困难模式生成地图
	else if (mazeLevel == 1)
	{
		mazeMap[1][1] = 5;
		mazeMap[1][2] = 6;
		mazeMap[2][1] = 6;
		createHardMaze(1, 1);
	}
	for (int i = 0; i < mazeCountX; i++)
	{
		for (int j = 0; j < mazeCountY; j++)
		{
			if (mazeMap[i][j] == 5)
			{
				mazeMap[i][j] = 1;

			}
		}
	}
	mazeMap[1][0] = 3;
	mazeMap[mazeCountX - 1][mazeCountY - 2] = 4;
}


void saveMaze()
{
	OPENFILENAME ofn;	//	公共对话框结构
	char szFile[MAX_PATH] = "";	//	同来保存获取文件名称的缓冲区
	ZeroMemory(&ofn, sizeof(ofn));	//	初始化文件选择窗口大小
	ofn.lStructSize = sizeof(ofn);	//	指定结构的大小，以字节为单位
	ofn.hwndOwner = NULL;	//	
	ofn.lpstrFilter = "Text Files (*.txt)\0*.txt\0All Files (*.*)\0*.*\0";	//	打开文件类型，文本类型
	ofn.lpstrFile = szFile;	//	打开的文件的全路径
	ofn.nMaxFile = MAX_PATH;	//	指定lpstrFile缓冲的大小，以TCHARs为单位
	ofn.Flags = OFN_EXPLORER | OFN_OVERWRITEPROMPT;	//	位标记的设置，用来初始化对话框

	if (GetSaveFileName(&ofn) == TRUE)
	{
		char filePath[MAX_PATH];
		strcpy(filePath, szFile);
		const char* fileExtension = ".txt";
		size_t extensionPos = strlen(filePath) - 4;
		if (extensionPos == 0 || strcmp(filePath + extensionPos, fileExtension) != 0)
		{
			strcat(filePath, fileExtension);
		}
		strcpy(szFile, filePath);
		FILE* file = fopen(szFile, "w");	//	写
		if (file != NULL)
		{
			for (int i = 0; i < mazeCountX; i++)
			{
				for (int j = 0; j < mazeCountY; j++)
				{
					fprintf(file, "%d,", mazeMap[i][j]);
				}
				fprintf(file, "\n");
			}
			fclose(file);
		}
	}
}


void openMaze()
{
	OPENFILENAME ofn;
	char szFile[MAX_PATH] = "";

	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = NULL;
	ofn.lpstrFilter = "Text Files (*.txt)\0*.txt\0All Files (*.*)\0*.*\0";
	ofn.lpstrFile = szFile;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST;

	if (GetOpenFileName(&ofn) == TRUE)
	{
		FILE* file = fopen(szFile, "r");	//	读
		if (file != NULL)
		{
			for (int i = 0; i < mazeCountX; i++)
			{
				for (int j = 0; j < mazeCountY; j++)
				{
					if (fscanf(file, "%d,", &mazeMap[i][j]) != 1)
					{
						fclose(file);
						return;
					}
				}
			}
			fclose(file);
		}
	}
}


int judgeMaze()
{
	int flag = 0;

	if (findPath(startX, startY, exitX, exitY) == 1)
	{
		flag = 1;
	}
		
	
	return flag;
}


void createEasyMaze(int xCur, int yCur)
{
	gameOver = 0;
	int x = xCur;
	int y = yCur;
	int flag = 0;
	int randPos = 0;

	//	如果四个方向都没有墙了，返回上一步，否则继续
	while (1)
	{
		flag = 0;
		flag = isHaveNeighbor(xCur, yCur);
		if (flag == 0)
		{
			return;
		}
		else
		{
			mazeMap[xCur][yCur] = 5;
			x = xCur;
			y = yCur;
			while (1)
			{
				randPos = rand() % 4;
				if (randPos == 0 && xCur >= 3 && mazeMap[xCur - 2][yCur] == 1)	//	上
				{
					xCur = xCur - 2;
				}
				else if (randPos == 1 && xCur < mazeCountX - 3 && mazeMap[xCur + 2][yCur] == 1)	//	下
				{
					xCur = xCur + 2;
				}
				else if (randPos == 2 && yCur >= 3 && mazeMap[xCur][yCur - 2] == 1)	//	左
				{
					yCur = yCur - 2;
				}
				else if (randPos == 3 && yCur < mazeCountX - 3 && mazeMap[xCur][yCur + 2] == 1)	//	右
				{
					yCur = yCur + 2;
				}
				else
				{
					if (isHaveNeighbor(x, y) == 0)
					{

						break;
					}
					else
					{

						continue;
					}
				}

				mazeMap[(x + xCur) / 2][(y + yCur) / 2] = 5;
				mazeMap[xCur][yCur] = 5;
				createEasyMaze(xCur, yCur);	//	递归
				break;
			}

		}
	}


}


void createHardMaze(int xCur, int yCur)
{
	gameOver = 0;
	int i = 0;
	int j = 0;
	int randPoint = 0;
	int x = 1;
	int y = 2;
	int flag = 0;
	while (1)
	{
		flag = isHaveNeighbor(xCur, yCur);
		if (flag == 0)
			return;
		else
		{
			while (1)
			{
				//	如果目前剩余1个蓝色方块
				if (flag == 1)
				{
					randPoint = 0;
				}

				else
				{
					randPoint = rand() % flag;	//	随机一个小于flag的数，用于随机选取蓝色方块
				}

				for (i = 0; i < mazeCountX; i++)
				{
					for (j = 0; j < mazeCountY; j++)
					{
						if (mazeMap[i][j] == 6 && randPoint == 0)
						{
							x = i;
							y = j;
							break;
						}
						else if (mazeMap[i][j] == 6)
						{
							randPoint--;
						}
					}
					if (mazeMap[i][j] == 6 && randPoint == 0)
					{
						break;
					}
				}
				if (mazeMap[x + 1][y] == 5)	//	向上
				{
					if (mazeMap[x - 1][y] == 1)
					{
						mazeMap[x - 1][y] = 5;
						mazeMap[x][y] = 5;
						x = x - 1;
					}
					else
					{
						mazeMap[x][y] = 0;
						break;
					}
				}
				else if (mazeMap[x - 1][y] == 5)	//	向下
				{
					if (mazeMap[x + 1][y] == 1)
					{
						mazeMap[x + 1][y] = 5;
						mazeMap[x][y] = 5;
						x = x + 1;
					}
					else
					{
						mazeMap[x][y] = 0;
						break;
					}
				}
				else if (mazeMap[x][y + 1] == 5)	//	向左
				{
					if (mazeMap[x][y - 1] == 1)
					{
						mazeMap[x][y - 1] = 5;
						mazeMap[x][y] = 5;
						y = y - 1;
					}
					else
					{
						mazeMap[x][y] = 0;
						break;
					}
				}
				else if (mazeMap[x][y - 1] == 5)	//	向右
				{
					if (mazeMap[x][y + 1] == 1)
					{
						mazeMap[x][y + 1] = 5;
						mazeMap[x][y] = 5;
						y = y + 1;
					}
					else
					{
						mazeMap[x][y] = 0;
						break;
					}
				}
				if (xCur > 1 && mazeMap[xCur - 1][yCur] == 0)
				{
					mazeMap[xCur - 1][yCur] = 6;
				}

				if (yCur > 1 && mazeMap[xCur][yCur - 1] == 0)
				{
					mazeMap[xCur][yCur - 1] = 6;
				}
				if (xCur < mazeCountX - 2 && mazeMap[xCur + 1][yCur] == 0)
				{
					mazeMap[xCur + 1][yCur] = 6;
				}

				if (yCur < mazeCountY - 2 && mazeMap[xCur][yCur + 1] == 0)
				{
					mazeMap[xCur][yCur + 1] = 6;
				}
				xCur = x;
				yCur = y;
				break;
			}
		}

	}

}


int isHaveNeighbor(int xCur, int yCur)
{
	int flag = 0;
	if (mazeLevel == 0)
	{


		if ((xCur >= 3 && mazeMap[xCur - 2][yCur] == 1) || (xCur < mazeCountX - 3 && mazeMap[xCur + 2][yCur] == 1)
			|| (yCur >= 3 && mazeMap[xCur][yCur - 2] == 1) || (yCur < mazeCountY - 3 && mazeMap[xCur][yCur + 2] == 1))
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}

	if (mazeLevel == 1)
	{
		for (int i = 0; i < mazeCountX; i++)
		{
			for (int j = 0; j < mazeCountY; j++)
			{
				if (mazeMap[i][j] == 6)	//	还存在蓝色方块
				{
					flag++;
				}

			}
		}
		return flag;
	}


}


void initQueue(struct Queue* queue)
{
	//	初始化队列
	queue->front = NULL;
	queue->rear = NULL;
}


bool isQueueEmpty(struct Queue* queue)
{
	return queue->front == NULL;
}


bool isPath(int x, int y)
{
	return (mazeMap[x][y] != 0);
}


bool isValid(int x, int y)
{
	return (x >= 0 && x < mazeCountX && y >= 0 && y < mazeCountY);
}


void enqueue(struct Queue* queue, int x, int y)
{
	struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
	newNode->x = x;
	newNode->y = y;
	newNode->next = NULL;

	if (queue->rear == NULL) 
	{
		queue->front = newNode;
		queue->rear = newNode;
	}
	else 
	{
		queue->rear->next = newNode;
		queue->rear = newNode;
	}
}


struct Node* dequeue(struct Queue* queue)
{
	if (queue->front == NULL) 
	{
		return NULL;
	}

	struct Node* node = queue->front;
	queue->front = queue->front->next;

	if (queue->front == NULL) 
	{
		queue->rear = NULL;
	}

	return node;
}


int findPath(int pathStartX, int pathStartY, int pathEndX, int pathEndY)
{
	int recordStart = mazeMap[pathStartX][pathStartY];
	int recordEnd = mazeMap[pathEndX][pathEndY];

	mazeMap[pathStartX][pathStartY] = 1;
	mazeMap[pathEndX][pathEndY] = 1;

	struct Queue queue;
	initQueue(&queue);

	for (int i = 0; i < mazeCountX; i++)
	{
		for (int j = 0; j < mazeCountY; j++)
		{
			path[i][j] = -1;
		}
	}

	int dx[] = { -1, 1, 0, 0 };
	int dy[] = { 0, 0, -1, 1 };

	enqueue(&queue, pathStartX, pathStartY);
	path[pathStartX][pathStartY] = -2;

	while (!isQueueEmpty(&queue))
	{
		struct Node* currentNode = dequeue(&queue);
		int currentX = currentNode->x;
		int currentY = currentNode->y;
		free(currentNode);

		if (currentX == pathEndX && currentY == pathEndY)
		{
			mazeMap[pathStartX][pathStartY] = recordStart;
			mazeMap[pathEndX][pathEndY] = recordEnd;
			return 1;
		}

		for (int i = 0; i < 4; i++)
		{
			int newX = currentX + dx[i];
			int newY = currentY + dy[i];

			if (isValid(newX, newY) && isPath(newX, newY) && path[newX][newY] == -1)
			{
				enqueue(&queue, newX, newY);
				path[newX][newY] = i;
			}
		}
	}

	mazeMap[pathStartX][pathStartY] = recordStart;
	mazeMap[pathEndX][pathEndY] = recordEnd;
	return 0;
}


void printPath(int pathStartX, int pathStartY, int pathEndX, int pathEndY)
{
	if (autoSolve == 1)
	{
		for (int i = 0; i < mazeCountX; i++)
		{
			for (int j = 0; j < mazeCountY; j++)
			{
				if (mazeMap[i][j] == 6)
				{
					mazeMap[i][j] = 1;
				}
			}
		}
	}

	int x = pathEndX;
	int y = pathEndY;
	int count = 0;
	int dx[] = { -1, 1, 0, 0 };
	int dy[] = { 0, 0, -1, 1 };

	while (x != pathStartX || y != pathStartY)
	{
		int direction = path[x][y];
		x = x - dx[direction];
		y = y - dy[direction];
		count++;
	}

	int pathLength = count + 1;
	struct Node** pathArray = (struct Node**)malloc(pathLength * sizeof(struct Node*));
	count = 0;
	x = pathEndX;
	y = pathEndY;

	while (x != pathStartX || y != pathStartY)
	{
		int direction = path[x][y];
		x = x - dx[direction];
		y = y - dy[direction];

		struct Node* node = (struct Node*)malloc(sizeof(struct Node));
		node->x = x;
		node->y = y;
		node->next = NULL;

		pathArray[count++] = node;
	}

	for (int i=pathLength-3; i>=0; i--)
	{
		if (mazeMap[pathArray[i]->x][pathArray[i]->y] == 1)
		{
			mazeMap[pathArray[i]->x][pathArray[i]->y] = 6;
		}
	}
	Show();

	for (int i = 0; i < pathLength - 1; i++)
	{
		free(pathArray[i]);
	}

	free(pathArray);
}


void printNextStep(int pathStartX, int pathStartY, int pathEndX, int pathEndY)
{
	for (int i = 0; i < mazeCountX; i++)
	{
		for (int j = 0; j < mazeCountY; j++)
		{
			if (mazeMap[i][j] == 6)
			{
				mazeMap[i][j] = 1;
			}
				
		}
	}
	int x = pathEndX;
	int y = pathEndY;
	int count = 0;
	int dx[] = { -1, 1, 0, 0 };
	int dy[] = { 0, 0, -1, 1 };

	while (x != pathStartX || y != pathStartY)
	{
		int direction = path[x][y];
		x = x - dx[direction];
		y = y - dy[direction];
		count++;
	}

	int pathLength = count + 1;
	struct Node** pathArray = (struct Node**)malloc(pathLength * sizeof(struct Node*));
	count = 0;
	x = pathEndX;
	y = pathEndY;

	while (x != pathStartX || y != pathStartY)
	{
		int direction = path[x][y];
		x = x - dx[direction];
		y = y - dy[direction];

		struct Node* node = (struct Node*)malloc(sizeof(struct Node));
		node->x = x;
		node->y = y;
		node->next = NULL;

		pathArray[count++] = node;
	}

	int i = pathLength - 3;
	if (i >= 0 && mazeMap[pathArray[i]->x][pathArray[i]->y] == 1)
	{
		mazeMap[pathArray[i]->x][pathArray[i]->y] = 6;
	}
	Show();

	for (int i = 0; i < pathLength - 1; i++)
	{
		free(pathArray[i]);
	}
	free(pathArray);
}
~~~

~~~c
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <windows.h>
#include <time.h>
#include <math.h>

#include "parameter.h"
#include "showmaze.h"
#include "maze.h"

#include"parameter.h"
#include "src/libgraphics/graphics.h"
#include "src/libgraphics/genlib.h"
#include "src/simpleGUI/imgui.h"
#include "src/libgraphics/extgraph.h"

void showIndex(void)
{
	DisplayClear();
	drawIndexButton();
}


void drawIndexButton()
{
	double startX, startY;

	//	左边红色的门
	SetPenSize(3);
	SetPenColor("Red");
	startX = indexIconX - 7.0 * indexIconX / 10.0;
	startY = indexIconY + 9.5 * WindowHeight / 10.0;
	MovePen(startX + 0.3 * mazeSize, startY - mazeSize);
	DrawLine(0, -7 * mazeSize);
	DrawLine(4 * mazeSize, 0);
	DrawLine(0, 7 * mazeSize);
	DrawLine(-4 * mazeSize, 0);
	MovePen(startX + 1 * mazeSize, startY - 3.2 * mazeSize);
	DrawArc(CircleSize, 0, 360);


	//	左边蓝色‘MAZE’字样
	MovePen(startX +  1.60*mazeSize, startY - 4.5*mazeSize);
	SetPointSize(30);
	SetPenColor("Blue");
	DrawTextString("MAZE");


	//	右边蓝色‘GAME’字样
	startX = -indexIconX + WindowWidth;
	MovePen(startX + 1.60 * mazeSize, startY - 4.5 * mazeSize);
	SetPointSize(30);
	SetPenColor("Blue");
	DrawTextString("GAME");


	//	右边绿色的门
	SetPenColor("Green");
	startX = -indexIconX + WindowWidth;
	startY = indexIconY + 9.5 * WindowHeight / 10.0;
	MovePen(startX + 0.3 * mazeSize, startY - mazeSize);
	DrawLine(0, -7 * mazeSize);
	DrawLine(4 * mazeSize, 0);
	DrawLine(0, 7 * mazeSize);
	DrawLine(-4 * mazeSize, 0);
	MovePen(startX + 1 * mazeSize, startY - 3.2 * mazeSize);
	DrawArc(CircleSize, 0, 360);


	//	左边黑色小车
	SetPenColor("Black");
	startX = indexIconX - 7.0 * indexIconX / 10.0;
	startY = indexIconY + WindowHeight;
	MovePen(startX + 1.3 * mazeSize, startY - 11.0 * mazeSize);
	DrawLine(2 * mazeSize, 0);
	DrawLine(1 * mazeSize, -1 * mazeSize);
	DrawLine(-4 * mazeSize, 0);
	DrawLine(1 * mazeSize, 1 * mazeSize);
	MovePen(startX + 1.3 * mazeSize, startY - 12.0 * mazeSize - 5 * CircleSize);
	DrawArc(5 * CircleSize, 0, 360);
	MovePen(startX + 4.3 * mazeSize, startY - 12.0 * mazeSize - 5 * CircleSize);
	DrawArc(5 * CircleSize, 0, 360);
	SetPenColor("Red");
	MovePen(startX + 2.0 * mazeSize, startY - 11.0 * mazeSize);
	DrawLine(0, mazeSize);
	DrawLine(0.5 * mazeSize, -0.5 * mazeSize);
	DrawLine(-0.5 * mazeSize, 0);


	//	右边绿色旗子
	startX = -indexIconX + WindowWidth;
	startY = indexIconY + WindowHeight;
	SetPenColor("Green");
	MovePen(startX + 1.5 * mazeSize, startY - 9.5 * mazeSize);
	DrawLine(0, -3.5 * mazeSize);
	MovePen(startX + 1.5 * mazeSize, startY - 9.5 * mazeSize);
	DrawLine(2 * mazeSize, -1.0 * mazeSize);
	DrawLine(-2.0 * mazeSize, -1.0 * mazeSize);

	
	SetFont("宋体");
	button(GenUIID(0), -0.1, -0.1, 0.1, 0.1, " ");


	//	开始游戏按钮
	if (button(GenUIID(0), indexStartButtonX, indexStartButtonY, indexButtonWidth, indexButtonHeight, "开始"))
	{
		DisplayClear();
		pageFlag = 2;
		Show = showGame;
		return;
	}


	//	帮助按钮
	if (button(GenUIID(0), indexHelpButtonX, indexHelpButtonY, indexButtonWidth, indexButtonHeight, "帮助"))
	{
		system("start .\\help\\用户使用手册.pdf");
	}


	//	退出按钮
	if (button(GenUIID(0), indexExitButtonX, indexExitButtonY, indexButtonWidth, indexButtonHeight, "退出"))
	{
		exit(0);
	}


	//	底部黑色字样
	SetPointSize(15);
	MovePen(indexExitButtonX + 0.25, indexIconY + mazeSize);
	SetPenColor("Black");
	DrawTextString("By mqqq333");

}


void showGame(void)
{
	DisplayClear();
	drawMazeMap();
	drawMazeOutline();
	drawGameButton();
}


void drawMazeMap()
{
	/*
		0	-	墙
		1	-	路
		3	-	起点
		4	-	终点
		6	-	提示
	*/
	for (int i = 0; i < mazeCountX; i++)
	{
		for (int j = 0; j < mazeCountY; j++)
		{
			double startX = mazeX + j * mazeSize;
			double startY = mazeY - i * mazeSize;
			

			//	墙
			if (mazeMap[i][j] == 0)
			{
				SetPenColor("Black");
				SetPenSize(2);
				double len = mazeSize / 8.0;


				// 外部轮廓
				MovePen(startX, startY);
				DrawLine(0, -mazeSize);
				DrawLine(mazeSize, 0);
				DrawLine(0, mazeSize);
				DrawLine(-mazeSize, 0);


				// 内部
				int k;
				for (k = 1; k <= 8; k++)
				{
					MovePen(startX + k * len, startY);
					DrawLine(-k * len, -k * len);
					MovePen(startX + mazeSize - k * len, startY - mazeSize);
					DrawLine(k * len, k * len);
				}

			}
			//	起点
			else if (mazeMap[i][j] == 3) 
			{
				SetPenColor("Red");
				SetPenSize(2);
				MovePen(startX + 0.4 * mazeSize, startY - mazeSize);
				DrawLine(0, 0.7 * mazeSize);
				DrawLine(0.3 * mazeSize, -0.2 * mazeSize);
				DrawLine(-0.3 * mazeSize, -0.1 * mazeSize);
				SetPenColor("Black");
				SetPenSize(1);
			}
			//	终点
			else if (mazeMap[i][j] == 4) 
			{
				SetPenColor("Green");
				SetPenSize(2);
				MovePen(startX + 0.4 * mazeSize, startY - mazeSize);
				DrawLine(0, 0.7 * mazeSize);
				DrawLine(0.3 * mazeSize, -0.2 * mazeSize);
				DrawLine(-0.3 * mazeSize, -0.1 * mazeSize);


				SetPenColor("Black");
				SetPenSize(1);

			}
			//	提示
			else if (mazeMap[i][j] == 6) 
			{
				SetPenColor("Green");
				SetPenSize(2);
				MovePen(startX + 0.68 * mazeSize, startY - 0.5 * mazeSize);
				DrawArc(CircleSize*1.25, 0, 360);


				SetPenSize(1);
				SetPenColor("Black");
			}
			
		}

	}
}


void drawMazeOutline()
{
	MovePen(mazeX, mazeY);
	SetPenColor("Black");
	SetPenSize(3);
	DrawLine(0.0, -mazeOutlineHeight);
	DrawLine(mazeOutlineWidth, 0.0);
	DrawLine(0.0, mazeOutlineHeight);
	DrawLine(-mazeOutlineWidth, 0.0);
	SetPenSize(1);
}


void drawGameButton()
{
	/***编辑区***/
	SetPenColor("Black");
	SetPenSize(1);
	SetPointSize(30);
	MovePen(gameAreaX+gameButtonWidth/4, gameAreaY2 + 3.2*gameButtonHeight);
	DrawTextString("编辑区");
	SetPointSize(15);
	//	添加墙
	 if (button(GenUIID(0), gameAreaX, gameAreaY2 + 2*gameButtonHeight, gameButtonWidth/2, gameButtonHeight, "添加墙"))
	{
		 editBlock = 0;
		 Show();
	}
	//	删除墙
	 if (button(GenUIID(0), gameAreaX+gameButtonWidth/2, gameAreaY2 + 2*gameButtonHeight, gameButtonWidth/2, gameButtonHeight, "删除墙"))
	{
		 editBlock = 1;
		 Show();
	}
	//	打开地图
	 if (button(GenUIID(0), gameAreaX, gameAreaY2+gameButtonHeight, gameButtonWidth/2, gameButtonHeight, "打开地图"))
	{
		 editBlock = -1;
		 openMaze();
		 Show();
		 
	}
	//	保存地图
	if (button(GenUIID(0), gameAreaX+gameButtonWidth/2, gameAreaY2 + gameButtonHeight, gameButtonWidth/2, gameButtonHeight, "保存地图"))
	{
		editBlock = -1;
		saveMaze();
		Show();
	}

	//	简单模式
	if (button(GenUIID(0), gameAreaX, gameAreaY2, gameButtonWidth/2, gameButtonHeight, "简单模式"))
	{
		mazeLevel = 0;
		initMaze();
		Show();
	}
	//	困难模式
	if (button(GenUIID(0), gameAreaX + gameButtonWidth / 2, gameAreaY2, gameButtonWidth / 2, gameButtonHeight, "困难模式"))
	{
		mazeLevel = 1;
		initMaze();
		Show();
	}


	/***操作区***/
	SetPenColor("Black");
	SetPenSize(1);
	SetPointSize(30);
	MovePen(gameAreaX + gameButtonWidth / 4, gameAreaY2- 0.8*gameButtonHeight);
	DrawTextString("操作区");
	SetPointSize(15);
	// 自动最近路线
	if (button(GenUIID(0), gameAreaX, gameAreaY2 - 2 * gameButtonHeight, gameButtonWidth, gameButtonHeight, "提示最近路线"))
	{
		autoSolve = 1;

		if (findPath(currentX, currentY, exitX, exitY) == 1)
		{
			printPath(currentX, currentY, exitX, exitY);
		}
		Show();
		
	}
	// 提示下一步
	if (button(GenUIID(0), gameAreaX, gameAreaY2 - 3 * gameButtonHeight, gameButtonWidth, gameButtonHeight, "提示下一步"))
	{
		autoSolve = 2;
		if (findPath(currentX, currentY, exitX, exitY) == 1)
		{
			printNextStep(currentX, currentY, exitX, exitY);
		}
		Show();
		
		
	}
	// 检查迷宫可行性
	if (button(GenUIID(0), gameAreaX, gameAreaY2 - 4 * gameButtonHeight, gameButtonWidth, gameButtonHeight, "检查迷宫可行性"))
	{
		if (judgeMaze())
		{
			MessageBox(NULL, "迷宫可行，请开始游戏！", "成功", MB_OK | MB_ICONINFORMATION);
		}
		else
		{
			MessageBox(NULL, "迷宫错误，请进行修改！", "错误", MB_OK | MB_ICONINFORMATION);
		}
	}
	//	操作说明
	if (button(GenUIID(0), gameAreaX, gameAreaY2 - 5 * gameButtonHeight, gameButtonWidth, gameButtonHeight, "操作说明"))
	{
		MessageBox(NULL, "请使用数字区上下左右键控制移动", "操作提示", MB_OK | MB_ICONINFORMATION);
	}

	// 退出游戏
	if (button(GenUIID(0), gameAreaX, gameAreaY2 - 6 * gameButtonHeight, gameButtonWidth, gameButtonHeight, "返回首页"))
	{
		DisplayClear();
		pageFlag = 1;
		Show = showIndex;
		for (int i = 0; i < mazeCountX; i++)
		{
			for (int j = 0; j < mazeCountY; j++)
			{
				mazeMap[i][j] = 0;
			}
		}
		return;
	}

	// 绘制工作区边框
	SetPenColor("Black");
	SetPenSize(3);

	//	整体大边框	
	drawRect(gameAreaX, gameAreaY1, gameAreaWidth, gameAreaHeight2);
	
	//	编辑区、操作区、返回首页边框	
	drawRect(gameAreaX, gameAreaY1, gameAreaWidth, gameAreaHeight1);
	drawRect(gameAreaX, gameAreaY2, gameAreaWidth, gameAreaHeight1);
	drawRect(gameAreaX, gameAreaY3, gameAreaWidth, gameAreaHeight1);
	
	SetPenSize(1);
}


void updateMaze()
{
	
	

	for (int i = 0; i < mazeCountX; i++)
	{
			for (int j = 0; j < mazeCountY; j++)
			{
				if (mazeMap[i][j] == 3)
				{
					startX = i;
					startY = j;
					currentX = i;
					currentY = j;
					if (pageFlag == 2)
					{
						mazeMap[i][j] = 3;
					}
				}
				else if (mazeMap[i][j] == 4)
				{
					exitX = i;
					exitY = j;
				}
				
		}
	}
	

}


void drawRect(double x, double y, double w, double h)
{
	MovePen(x, y);
	DrawLine(0, -h);
	DrawLine(w, 0);
	DrawLine(0, h);
	DrawLine(-w, 0);
}


void mouseEventProcess(int x, int y, int button, int event)
{
	uiGetMouse(x, y, button, event);
	if (event == BUTTON_DOWN)
	{
		int blockX, blockY;
		blockY = (ScaleXInches(x) * 1.0 - mazeX) / mazeSize;
		blockX = (mazeY - ScaleYInches(y) * 1.0) / mazeSize;
		if (editBlock >= 0 && blockX >= 0 && blockX < mazeCountX && blockY >= 0 && blockY < mazeCountY)
		{
			mazeMap[blockX][blockY] = editBlock;

		}
	}
	
	updateMaze();
	Show();
}


void keyboardEventProcess(int key, int event)
{
	uiGetKeyboard(key, event);
	if (event == KEY_DOWN && gameOver == 0)
	{
		if (key == VK_LEFT)
		{
			if (currentY != 0)
			{

				if (mazeMap[currentX][currentY - 1] == 4)
				{
					gameOver = 1;
				 }

				if ((mazeMap[currentX][currentY - 1] == 1) || (mazeMap[currentX][currentY - 1] == 6))
				{
					mazeMap[currentX][currentY-1] = 3;
					
					mazeMap[currentX][currentY] = 1;
				}
			}
			if (gameOver == 1)
			{
				int result = MessageBox(NULL, "恭喜！你通过了这一难度！", "恭喜", MB_OK | MB_ICONINFORMATION);
				if (result == IDOK)
				{
					Show = showIndex;
				}
			}
		}
		if (key == VK_RIGHT)
		{
			if (currentY != mazeCountY-1)
			{
				if (mazeMap[currentX][currentY + 1] == 4)
				{
					gameOver = 1;
				}
				if ((mazeMap[currentX][currentY + 1] == 1) || (mazeMap[currentX][currentY + 1] == 6))
				{
					mazeMap[currentX][currentY+1] = 3;
					
					mazeMap[currentX][currentY] = 1;
				}
			}
			if (gameOver == 1)
			{
				int result = MessageBox(NULL, "恭喜！你通过了这一难度！", "恭喜", MB_OK | MB_ICONINFORMATION);
				if (result == IDOK)
				{
					Show = showIndex;
				}
			}
		}
		if (key == VK_UP)
		{
			if (currentX != 0)
			{

				if (mazeMap[currentX - 1][currentY] == 4)
				{
					gameOver = 1;
				}

				if ((mazeMap[currentX - 1][currentY] == 1) || (mazeMap[currentX-1][currentY] == 6))
				{
					mazeMap[currentX-1][currentY] = 3;
					
					mazeMap[currentX][currentY] = 1;
				}
			}
			if (gameOver == 1)
			{
				int result = MessageBox(NULL, "恭喜！你通过了这一难度！", "恭喜", MB_OK | MB_ICONINFORMATION);
				if (result == IDOK)
				{
					Show = showIndex;
				}

			}
		}


		if (key == VK_DOWN)
		{
			if (currentX != mazeCountX-1)
			{

				if (mazeMap[currentX + 1][currentY] == 4)
				{
					gameOver = 1;
				}
				if ((mazeMap[currentX + 1][currentY] == 1 ) || (mazeMap[currentX+1][currentY] == 6))
				{
					mazeMap[currentX+1][currentY] = 3;
					
					mazeMap[currentX][currentY] = 1;
				}
			}
			if (gameOver == 1)
			{
				int result = MessageBox(NULL, "恭喜！你通过了这一难度！", "恭喜", MB_OK | MB_ICONINFORMATION);
				if (result == IDOK)
				{
					Show = showIndex;
				}

			}
		}
		if (autoSolve == 1)
		{
			if (findPath(currentX, currentY, exitX, exitY) == 1)
			{
				printPath(currentX, currentY, exitX, exitY);
			}
		}
		else if (autoSolve == 2)
		{

			if (findPath(currentX, currentY, exitX, exitY) == 1)
			{
				printNextStep(currentX, currentY, exitX, exitY);
			}
		}
		else if (autoSolve == 0)
		{
			for (int i = 0; i < mazeCountX; i++)
			{
				for (int j = 0; j < mazeCountY; j++)
				{
					if (mazeMap[i][j] == 6)
					{
						mazeMap[i][j] = 1;
					}
				}
			}
		}
		updateMaze();
	}

	Show();
}

~~~

~~~c
#ifndef _H_PARAMETER
#define _H_PARAMETER
//  窗口大小
#define WindowWidth 12
#define WindowHeight 7


/***迷宫参数***/
#define mazeCountX 13
#define mazeCountY 13
int mazeMap[mazeCountX][mazeCountY];
int path[mazeCountX][mazeCountY];   //  存放路径
static int mazeLevel = 0;   //  迷宫难度
                            //  0   -   简单模式
                            //  1   -   困难模式

static int autoSolve = 0;   //  提示类型
                            //  0   -   无提示
                            //  1   -   提示最短路径
                            //  2   -   提示下一步


// 首页相关参数
#define indexButtonWidth 1.5
#define indexButtonHeight 0.5
#define indexStartButtonX 5.0
#define indexStartButtonY 5.8
#define indexHelpButtonX 5.0
#define indexHelpButtonY 4.3
#define indexExitButtonX 5
#define indexExitButtonY 2.8
#define indexIconX 4.0
#define indexIconY 0.2


/***游戏界面参数***/
//  迷宫相关
#define mazeX 1.0
#define mazeY 6.5
#define mazeOutlineHeight 5.85
#define mazeOutlineWidth 5.85
#define mazeSize 0.45


//  操作区相关
#define gameAreaX 8
#define gameAreaY1 6
#define gameAreaY2 4.0
#define gameAreaY3 1.5
#define gameAreaWidth 2.0
#define gameAreaHeight1 0.5
#define gameAreaHeight2 5.0
#define gameButtonWidth 2.0
#define gameButtonHeight 0.5


/***位置参数***/  
//  起点
int startX;
int startY;
//  当前位置
int currentX;
int currentY;
//  终点
int exitX;
int exitY;

//  其他参数
int gameOver;   //  记录游戏结束与否，1则结束
int editBlock;  //  为1则生成墙块
int pageFlag;   //  1为首页，2为游戏界面
#define CircleSize 0.05 //  弧线半径
//  节点
struct Node
{
    int x;
    int y;
    struct Node* next;
};
//  队列
struct Queue
{
    struct Node* front;
    struct Node* rear;
};
#endif
~~~