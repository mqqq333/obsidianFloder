#链表 #线性表 #顺序表
## 单链表
链表的创建
~~~c
// Define node
struct Node
{
	int data;
	struct Node *next;
}

typedef struct Node
{
	int data;
	struct Node *next;
}Node;

// Define head, tail pointer
struct Node *head = NULL;
struct Node *tail = NULL;
struct Node *p = NULL;
// Create a linked list that stores {1, 2, 3, 4, 5, 6} 
struct Node *createlist()
{
	p = (struct Node *)malloc(sizeof(struct Node));
	p->data = 0;
	p->next = NULL;
	head = p;
	for(int i=1; i<6; i++)
	{
		p = (struct Node *)malloc(sizeof(struct Node));
		p->data = i; 
		p->next = NULL;
		head->next = p;
		head = head->next;
	}
	return head;                
}
// Add new node
if (head == NULL)
{
	tail = (struct *Node)malloc(sizeof(struct Node));
	head = tail;
}
else
{
	tail->next = (struct Node*)malloc(sizeof(struct   Node));
	tail = tail->next;
}
tail->data = _data;
tail->next = NULL;

// Create list
struct Node * createlist()
{
	struct Node *p, *head, *tail = NULL;
	p = (struct Node*)malloc(sizeof(struct Node));
	scanf("%d", &p->data)
	while(p->data != 0 )
	{
		p->next = NULL;
		
		if(head == NULL)
		{
			head = p;
		}
		else
		{
			tail->next = p;
		}
		tail = p;
		p = (struct Node*)malloc(sizeof(struct Node));
		scanf("%d",&p->data);
	}
	p = NULL;
	return head;
}
// Traverse the list
p = head;
while(p)
{
	printf("%d\n",p->data);
	p = p->next;
}
~~~
链表插入元素
- 头部，作首节点
- 中间
- 尾部，尾节点
![[Pasted image 20230518184545.png]]

~~~c
void insert(struct Node* head, int insert_data, int pos)
{
	// Insert new node to the end
	for(p=head; p->next!=NULL； p=p->next);

	struct Node *new_node = (struct Node*)malloc(sizeof(struct   Node));
	new_node->next = NULL;
	p->next = new_node;

	//Insert to the pos
	p = head;
	for(int i=1; i<pos; i++)
	{
		p = p->next;
		if(p == NULL)
		{
			printtf("Invild pos;")
			return;
		}
	}
	struct Node *new_node* = (struct Node*)malloc(sizeof(struct Node));
	new_node->data = insert_data;
	new_node->next = p->next;
	p->next = new_node;
}
void delete(struct Node* head, int del_data)
{
	// delete the last node
	//对于有头结点的链表来说，无论删除头部（首元结点）、中部、
	//尾部的结点，实现方式都一样，执行以下三步操作：  
	//1.  找到目标元素所在结点的直接前驱结点；
	//2.  将目标结点从链表中摘下来;
	//3.  手动释放结点占用的内存空间；
	p = head;
	if(p->data == del_data)
	{
		head = p->next;
		free(p);
		return 1;
	}
	else
	{
		int find = 0;
		while(p->next)
		{
			if(p->next->data == del_data)
			{
				find = 1;
				break;
			}
		}
		if(find == 0)
		{
			return -1;
		}
		else
		{
			del_node = p->next;
			p->next = p->next->next;
			free(del_node);
			return 1;
		}		
	}
}
int amend_data(struct Node* head, int old_data, int new_data)
{
	p = head->next;
	while(p)
	{
		if(p->data == old_data)
		{
			
		}
	}
}
// Insert between p and p->next

struct Node *node = (struct Node*)malloc(sizeof(struct   Node));
node->data = _data;
node->next = p->next;
p->next = node;

~~~
***链表的增删查改***
~~~c
#include <stdio.h>
#include <stdlib.h>
//链表中节点的结构
typedef struct link {
    int  elem;
    struct link* next;
}Link;
Link* initLink() {
    int i;
    //1、创建头指针
    Link* p = NULL;
    //2、创建头结点
    Link* temp = (Link*)malloc(sizeof(Link));
    temp->elem = 0;
    temp->next = NULL;
    //头指针指向头结点
    p = temp;
    //3、每创建一个结点，都令其直接前驱结点的指针指向它
    for (i = 1; i < 5; i++) {
        //创建一个结点
        Link* a = (Link*)malloc(sizeof(Link));
        a->elem = i;
        a->next = NULL;
        //每次 temp 指向的结点就是 a 的直接前驱结点
        temp->next = a;
        //temp指向下一个结点（也就是a),为下次添加结点做准备
        temp = temp->next;
    }
    return p;
}
//p为链表，elem为目标元素，add为要插入的位置
void insertElem(Link* p, int elem, int add) {
    int i;
    Link* c = NULL;
    Link* temp = p;//创建临时结点temp
    //首先找到要插入位置的上一个结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
        if (temp == NULL) {
            printf("插入位置无效\n");
            return;
        }
    }
    //创建插入结点c
    c = (Link*)malloc(sizeof(Link));
    c->elem = elem;
    //① 将新结点的 next 指针指向插入位置后的结点
    c->next = temp->next;
    //② 将插入位置前结点的 next 指针指向插入结点；
    temp->next = c;
}
//p为原链表，elem 为要删除的目标元素
int delElem(Link* p, int elem) {
    Link* del = NULL, *temp = p;
    int find = 0;
    //1、找到目标元素的直接前驱结点
    while (temp->next) {
        if (temp->next->elem == elem) {
            find = 1;
            break;
        }
        temp = temp->next;
    }
    if (find == 0) {
        return -1;//删除失败
    }
    else
    {
        //标记要删除的结点
        del = temp->next;
        //2、将目标结点从链表上摘除
        temp->next = temp->next->next;
        //3、释放目标结点
        free(del);
        return 1;
    }
}
//p为原链表，elem表示被查找元素
int selectElem(Link* p, int elem) {
    int i = 1;
    //带头结点，p 指向首元结点
    p = p->next;
    while (p) {
        if (p->elem == elem) {
            return i;
        }
        p = p->next;
        i++;
    }
    return -1;//返回-1，表示未找到
}
//p 为有头结点的链表，oldElem 为旧元素，newElem 为新元素
int amendElem(Link* p, int oldElem, int newElem) {
    p = p->next;
    while (p) {
        if (p->elem == oldElem) {
            p->elem = newElem;
            return 1;
        }
        p = p->next;
    }
    return -1;
}
//输出链表中各个结点的元素
void display(Link* p) {
    p = p->next;
    while (p) {
        printf("%d ", p->elem);
        p = p->next;
    }
    printf("\n");
}
//释放链表
void Link_free(Link* p) {
    Link* fr = NULL;
    while (p->next)
    {
        fr = p->next;
        p->next = p->next->next;
        free(fr);
    }
    free(p);
}
int main() {
    Link* p = initLink();
    printf("初始化链表为：\n");
    display(p);
    printf("在第 3 的位置上添加元素 6：\n");
    insertElem(p, 6, 3);
    display(p);
    printf("删除元素4：\n");
    delElem(p, 4);
    display(p);
    printf("查找元素 2：\n");
    printf("元素 2 的位置为：%d\n", selectElem(p, 2));
    printf("更改元素 1 的值为 6：\n");
    amendElem(p, 1, 6);
    display(p);
    Link_free(p);
    return 0;
}
~~~
单链表是最简单的一种链表实现方式，它包含两个域，一个信息域和一个指针域：![[Pasted image 20230516152359.png]]
```c

```
真正的单链表它还需要一个头指针，用于存放指向链表第一个节点的地址（这样你才能知道到它）：
![[Pasted image 20230516152427.png]]

***book结构体链表***
~~~c
// basic e.g.
extern struct node *head;
struct Node
{
	int data;
	struct Node *next;
}node;

// book struct list
struct Book
{
	char title[128];
	char author[40];
	float price;
	struct Date date;
	char publisher[40];
	struct Book *next;
};


~~~

在单链表种插入元素（头插法）

![[Pasted image 20230518200114.png]]
~~~c
void addBook(struct Book **library)
{
	struct Book *book, *temp;
	book = (struct Book *)malloc(sizeof(struct Book));
	if(book = NULL)
	{
		printf("Memory allocated failed.");
		exit(1);
	}
	getInput(book);
	if(*library != NULL)
	{
		temp = library;
		*library = book;
		book->next = temp;
	}
	else
	{
		*library = book;
		book->next = NULL;
	}
}
~~~

尾插法
![[Pasted image 20230518201242.png]]
~~~c

void addBook(struct Book **library)
{

        struct Book *book;

        static struct Book *tail;


        book = (struct Book *)malloc(sizeof(struct Book));

        if (book == NULL)

        {

                printf("内存分配失败！\n");

                exit(1);

        }


        getInput(book);


        if (*library != NULL)

        {

                tail->next = book;

                book->next = NULL;

        }

        else

        {

                *library = book;

                book->next = NULL;

        }


        tail = book;

}

~~~

**搜索单链表**

~~~c
struct Book *searchBook(struct Book *library, char *target)
{

        struct Book *book;


        book = library;

        while (book != NULL)

        {

                if (!strcmp(book->title, target) || !strcmp(book->author, target))

                {

                        break;

                }

                book = book->next;

        }


        return book;

}


void printBook(struct Book *book)

{

        printf("书名：%s\n", book->title);

        printf("作者：%s\n", book->author);

}

...

int main(void)

{

        ...

        printf("\n请输入书名或作者：");

        scanf("%s", input);


        book = searchBook(library, input);

        if (book == NULL)

        {

                printf("很抱歉，没能找到！\n");

        }

        else

        {

                do

                {

                        printf("已找到符合条件的书籍...\n");

                        printBook(book);

                } while ((book = searchBook(book->next, input)) != NULL);

        }


        releaseLibrary(&library);


        return 0;

}

~~~

插入
~~~c
//头插法相应操作

if(*library!=NULL)          //单链表头插法的两种情况，相应的操作

        {

                temp=*library;

                *library=book;

                book->next=temp;

        }

        else

        {

                *library=book;

                book->next=NULL;

        }



//尾插法相应的操作     每次调用函数都循环遍历找到尾指针效率很低，推荐用指针存储每次调用后的 尾部位置！！！1                        

        if(*library==NULL)

        {

                *library=book;

                book->next=NULL;       

        }       

        else

        {//设置一个中转变量，并循环遍历单链表直至找到 最后一个节点结束，所以temp此时存储的是最后一个节点地址               

                temp=*library;

                while(temp->next!=NULL)  

                {

                        temp=temp->next;

                }

                temp->next=book;

                book->next=NULL;

        }


//高效版，用尾指针存储每次添加书籍之后的位置，所以定义一个尾指针tail来存储单链表尾部的地址。

        static struct Book *tail;  //这里很关键，必须是static类型的，不没有的话会造成每一次调用add函数时，tail重新初始化了。

        ……

        if(*library==NULL)

        {

                *library=book;

                book->next=NULL;       

        }       

        else

        {            

                tail->next=book;

                book->next=NULL;

        }

        tail=book;

~~~


**插入节点到指定的位置**
![[Pasted image 20230518202903.png]]
~~~c
#include <stdio.h>

#include <stdlib.h>


struct Node

{

        int value;

        struct Node *next;

};


void insertNode(struct Node **head, int value)

{

        struct Node *previous;

        struct Node *current;

        struct Node *new;


        current = *head;

        previous = NULL;


        while (current != NULL && current->value < value)

        {

                previous = current;

                current = current->next;

        }


        new = (struct Node *)malloc(sizeof(struct Node));

        if (new == NULL)

        {

                printf("内存分配失败！\n");

                exit(1);

        }

        new->value = value;

        new->next = current;


        if (previous == NULL)

        {

                *head = new;

        }

        else

        {

                previous->next = new;

        }

}


void printNode(struct Node *head)

{

        struct Node *current;


        current = head;

        while (current != NULL)

        {

                printf("%d ", current->value);

                current = current->next;

        }


        putchar('\n');

}


int main(void)

{

        struct Node *head = NULL;

        int input;


        printf("开始测试插入整数...\n");

        while (1)

        {

                printf("请输入一个整数(输入-1表示结束)：");

                scanf("%d", &input);

                if (input == -1)

                {

                        break;

                }

                insertNode(&head, input);

                printNode(head);

        }

        

        return 0;

}


[fishc@localhost s1e47]$ gcc test1.c && ./a.out

开始测试插入整数...

请输入一个整数(输入-1表示结束)：5

5

请输入一个整数(输入-1表示结束)：3

3 5

请输入一个整数(输入-1表示结束)：8

3 5 8

请输入一个整数(输入-1表示结束)：9

3 5 8 9

请输入一个整数(输入-1表示结束)：1

1 3 5 8 9

请输入一个整数(输入-1表示结束)：0

0 1 3 5 8 9

请输入一个整数(输入-1表示结束)：2

0 1 2 3 5 8 9

请输入一个整数(输入-1表示结束)：4

0 1 2 3 4 5 8 9

请输入一个整数(输入-1表示结束)：7

0 1 2 3 4 5 7 8 9

请输入一个整数(输入-1表示结束)：-1



while (current != NULL && current->value < value)

{

        previous = current;

        current = current->next;

}

~~~

while 函数用于找到符合条件的链表节点，也就是在有序的链表中找到比传入的value更大的值，然后停下来；如果没有，则在链表的尾部位置停止（current == NULL 时结束循环）。  
  
由于单链表一旦指向下一个节点，就没办法回头了，所以我们使用 previous 变量来记录 current 节点的上一个节点。
![[Pasted image 20230518203054.png]]

最后判断一下 previous 变量，如果为 NULL 的话，说明 while 循环它压根儿就没进去过，有两种情况，要么是这是一个空链表（current == NULL），或者该值比当前链表中所有的节点的 value 成员都小，无论是哪一种情况，我们都将该值插入为单链表的第一个节点即可。


**在单链表中删除元素**
我们的单链表应该支持删除某一个节点的数据。  
  
删除某个节点的数据，其实也是修改指针的事儿，两个步骤搞定：  
  

-   修改待删除节点的上一个节点的指针，将其指向待删除节点的下一个节点
-   释放待删除节点的内存空间![[Pasted image 20230518203120.png]]

~~~c
void deleteNode(struct Node **head, int value)

{

        struct Node *previous;

        struct Node *current;


        current = *head;

        previous = NULL;


        while (current != NULL && current->value != value)

        {

                previous = current;

                current = current->next;

        }


        if (current == NULL)

        {

                printf("找不到匹配的节点！\n");

                return ;

        }

        else

        {

                if (previous == NULL)

                {

                        *head = current->next;

                }

                else

                {

                        previous->next = current->next;

                }

                free(current);

        }

}

[fishc@localhost s1e47]$ gcc test2.c && ./a.out

开始测试插入整数...

请输入一个整数(输入-1表示结束)：5

5

请输入一个整数(输入-1表示结束)：3

3 5

请输入一个整数(输入-1表示结束)：1

1 3 5

请输入一个整数(输入-1表示结束)：9

1 3 5 9

请输入一个整数(输入-1表示结束)：8

1 3 5 8 9

请输入一个整数(输入-1表示结束)：7

1 3 5 7 8 9

请输入一个整数(输入-1表示结束)：0

0 1 3 5 7 8 9

请输入一个整数(输入-1表示结束)：-1

开始测试删除整数...

请输入一个整数(输入-1表示结束)：0

1 3 5 7 8 9

请输入一个整数(输入-1表示结束)：9

1 3 5 7 8

请输入一个整数(输入-1表示结束)：7

1 3 5 8

请输入一个整数(输入-1表示结束)：8

1 3 5

请输入一个整数(输入-1表示结束)：-1

~~~

简单分析一下实现代码，当 current 指向 NULL 的情况有两种，要么这是一个空链表，要么在单链表的所有节点的 value 成员中找不到对应的数值，所以统一跟用户说找不到即可。  
  
如果 current 不为 NULL，我们还要预防 previous 是否为 NULL，有一种情况会导致这种局面的发生，那就是当要删除的节点是单链表的第一个节点的时候，在这种情况下需要特殊处理：要将 head 指针指向该节点。  
  
这个链表的知识，说白了就是考核你对结构体和指针的理解程度。  
  
在编程学习的初期阶段，你不可避免会遇到比如“自己思前想后毫无头绪，但一看到代码思路立马就清晰了！”类似这样的体验，总的来说，就是你看得多，练得少导致的。  
  
学习编程总的来说就是一个量变引发质变的过程，不要怕出错，不要吝啬于练习，你打的代码越多，你的功力就越深厚。

~~~c
void insertNode(struct Node **head,int value)
{
        struct Node *previous,*new,*current;
        previous=NULL;
        current=*head;
        new=(struct Node *)malloc(sizeof(struct Node));
        if(new==NULL)
        {
                printf("内存分配失败！");
                exit(1);
        }
        while(current!=NULL && current->value<value)
        {
                previous=current;
                current=current->next;
        }
        if(previous==NULL)
        {
                *head=new;
        }
        else
        {
                previous->next=new;
        }
        new->value=value;
        new->next=current;
}


void deleteNode(struct Node **head,int value)
{
        struct Node *previous,*current;
        current=*head;
        previous=NULL;
        while(current!=NULL && current->value!=value)
        {
                previous=current;
                current=current->next;
        }
        if(current==NULL)
        {
                printf("找不到！\n");
                return ;
        }
        else
        {
                if(previous==NULL)
                {
                        *head=current->next;
                }
                else
                {
                        previous->next=current->next;
                }
        }
        free(current);
}
~~~